# 다형성

### 1. 다형성
- 하나의 추상 인터페이스에 대해 코드를 작성하고 이 추상 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 능력
> Polymorphism(다형성)
> - Universal
>   - 매개변수(Parametric)
>   - 포함(Inclusion)
> - 임시(Ad Hoc)
>   - 오버로딩(Overloading)
>   - 강제(Coercion)

- 오버로딩 다형성: 하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우
- 강제 다형성: 동일한 연산자를 다양한 타입에 사용할 수 있는 방식
- 매개변수 다형성: (제네릭과 유사) 클래스의 인스턴스 변수나 메서드의 매개변수 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식
- 포함 다형성(서브타입 다형성): 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력

### 2. 상속의 양면성
- 객체지향 패러다임의 근간을 이루는 아이디어는 데이터와 행동을 객체라고 불리는 하나의 실행 단위 안으로 통합하는 것이다.
- 상속의 목적은 코드 재사용이 아니다.
- ***상속은 프로그램을 구성하는 개념들을 기반으로 다형성을 가능하게 하는 타입 계층을 구축하기 위한 것이다.***
- **업캐스팅, 동적 메서드 탐색, 동적 바인딩, self 참조, super 참조**

#### 데이터 관점의 상속
- **자식 클래스의 인스턴스는 자동으로 부모 클래스에서 정의한 모든 인스턴스 변수를 내부에 포함하게 되는 것이다.**

```java
Lecture lecture = new Lecture("객체지향 프로그래밍",
        70,
        Arrays.asList(81, 95, 75, 50, 45));

Lecture gradeLecture = new GradeLecture("객체지향 프로그래밍",
        70,
        Arrays.asList(new Grade("A", 100, 95),
                      new Grade("B", 94, 80),
                      new Grade("C", 79, 70),
                      new Grade("D", 69, 50),
                      new Grade("F", 49, 0)),
        Arrays.asList(81, 95, 75, 50, 45)); 
```

- 상속을 인스턴스 관점에서 볼 때는 개념적으로 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스가 포함되는 것으로 생각하는 것이 유용하다.
- 인스턴스를 참조하는 lecture는 GradeLecture의 인스턴스를 가리키기 때문에 Lecture 인스턴스에 직접 접근 불가

#### 행동 관점의 상속
- **부모 클래스가 정의한 일부 메서드를 자식 메서드로 포함시키는 것**
- 런타임에 시스템이 자식 클래스에 정의되지 않은 메서드가 있을 경우 이 메서드를 부모 클래스 안에서 탐색하기 때문이다.
- (자식 클래스에 정의되지 않은 메서드를 찾기 위해 부모 클래스가 언제든 탐색될 수 있다 -> 강한 결합을 사용해도 괜찮은 경우로 사용해야 겠다.)

### 3. 업캐스팅과 동적 바인딩
- 같은 메시지, 다른 메서드
  
#### 업캐스팅
- 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것이 가능하다.
- 여기서 자식 클래스는 현재 상속 계층에 존재하는 자식 클래스뿐만 아니라 앞으로 추가될지도 모르는 미래의 자식 클래스들을 포함한다.
- Lecture의 모든 자식 클래스는 evaluate 메시지를 이해할 수 있기 때문에 이 설계는 유연하며 확장이 용이하다.

```java
// 다운 캐스팅
Lecture lecture = new GradeLecture(...);
```

#### 동적 바인딩
- 실행될 메서드를 런타임에 결정하는 방식
- 선언된 변수의 타입이 아니라 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 결정된다.
- 업캐스팅과 동적 메서드 탐색(바인딩)은 코드를 변경하지 않고도 기능을 추가할 수 있게 해주며 개방-폐쇄 원칙(OCP)의 의도와도 일치한다. (단치 추상화가 아닐뿐)


### 4. 동적 메서드 탐색과 다형성
- 자동적인 메시지 위임
- 동적인 문맥
- 이해할 수 없는 메시지
- self 대 super

### 5. 상속 대 위임
- 위임과 self 참조
- 프로토타입 기반의 객체지향 언어
- 
